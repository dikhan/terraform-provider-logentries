package insight

import (
	"fmt"
	"github.com/dikhan/insight_goclient"
	"github.com/hashicorp/terraform/helper/schema"
	"github.com/mitchellh/mapstructure"
)

func logSetsResource() *schema.Resource {
	return &schema.Resource{
		Create: createLogSet,
		Read:   readLogSet,
		Delete: deleteLogSet,
		Update: updateLogSet,
		Importer: &schema.ResourceImporter{
			State: importLogSetHelper,
		},
		Schema: map[string]*schema.Schema{
			"name": {
				Type:     schema.TypeString,
				Required: true,
			},
			"description": {
				Type:     schema.TypeString,
				Optional: true,
			},
			"logs_info": {
				Type:     schema.TypeList,
				Elem:     &schema.Schema{Type: schema.TypeString},
				Optional: true,
			},
			"user_data": {
				Type:     schema.TypeMap,
				Elem:     &schema.Schema{Type: schema.TypeString},
				Optional: true,
			},
		},
	}
}

func createLogSet(data *schema.ResourceData, i interface{}) error {
	var p insight_goclient.PostLogSet
	var err error

	if p, err = makeLogSet(data); err != nil {
		return err
	}

	leClient := i.(insight_goclient.LogEntriesClient)
	logSet, err := leClient.LogSets.PostLogSet(p)

	if err != nil {
		return err
	}
	data.SetId(logSet.Id)
	return nil
}

func importLogSetHelper(data *schema.ResourceData, i interface{}) ([]*schema.ResourceData, error) {
	name := data.Id()
	leClient := i.(insight_goclient.LogEntriesClient)
	logSets, err := leClient.LogSets.GetLogSets()
	if err != nil {
		return nil, err
	}
	for _, logSet := range logSets {
		if logSet.Name == name {
			data.SetId(logSet.Id)
			readLogSet(data, i)
			return []*schema.ResourceData{data}, nil
		}
	}
	return []*schema.ResourceData{}, fmt.Errorf("No logset with name %s found.", name)
}

func readLogSet(data *schema.ResourceData, i interface{}) error {
	leClient := i.(insight_goclient.LogEntriesClient)
	logSet, _, err := leClient.LogSets.GetLogSet(data.Id())

	if err != nil {
		return nil
	}

	data.Set("name", logSet.Name)
	data.Set("description", logSet.Description)

	// This value might be auto-generated by the remote server if a log is added to the logset from the log api.
	// To prevent inconsistencies with the user input data, if the user set up a log for the logset then the read
	// will try and get info about the remote logs and see if there are differences; otherwise it will take it as
	// it is not desired to have a log attached to the logset
	localLogsInfo := []string{}
	if err := mapstructure.Decode(data.Get("logs_info").([]interface{}), &localLogsInfo); err != nil {
		return err
	}
	if len(localLogsInfo) != 0 {
		var logsInfo []string
		for _, logInfo := range logSet.LogsInfo {
			logsInfo = append(logsInfo, logInfo.Id)
		}
		data.Set("logs_info", logsInfo)
	}
	data.Set("user_data", logSet.UserData)
	return nil
}

func updateLogSet(data *schema.ResourceData, i interface{}) error {
	var p insight_goclient.PutLogSet
	var err error

	leClient := i.(insight_goclient.LogEntriesClient)
	if p, err = makePutLogSet(data, &leClient); err != nil {
		return err
	}

	logSet, err := leClient.LogSets.PutLogSet(data.Id(), p)
	if err != nil {
		return err
	}
	data.SetId(logSet.Id)
	return nil
}

func deleteLogSet(data *schema.ResourceData, i interface{}) error {
	logSetId := data.Id()
	leClient := i.(insight_goclient.LogEntriesClient)
	if err := leClient.LogSets.DeleteLogSet(logSetId); err != nil {
		return err
	}
	return nil
}

func decodeLogsInfo(data *schema.ResourceData, fetchRemote bool, client *insight_goclient.LogEntriesClient) ([]insight_goclient.PostLogInfo, []insight_goclient.LogInfo, error) {
	logsInfo := []string{}
	if err := mapstructure.Decode(data.Get("logs_info").([]interface{}), &logsInfo); err != nil {
		return nil, nil, err
	}

	decodedLogsInfo := []insight_goclient.LogInfo{}
	decodedPostLogsInfo := []insight_goclient.PostLogInfo{}
	for _, logId := range logsInfo {
		if fetchRemote {
			_, logInfo, err := client.Logs.GetLog(logId)
			if err != nil {
				return nil, nil, err
			}
			decodedLogsInfo = append(decodedLogsInfo, logInfo)
		} else {
			decodedPostLogsInfo = append(decodedPostLogsInfo, insight_goclient.PostLogInfo{logId})
		}
	}
	return decodedPostLogsInfo, decodedLogsInfo, nil
}

func makeLogSet(data *schema.ResourceData) (insight_goclient.PostLogSet, error) {
	var logsInfo []insight_goclient.PostLogInfo
	var decodedUserData map[string]string
	var err error

	if logsInfo, _, err = decodeLogsInfo(data, false, nil); err != nil {
		return insight_goclient.PostLogSet{}, err
	}

	if err := mapstructure.Decode(data.Get("user_data").(map[string]interface{}), &decodedUserData); err != nil {
		return insight_goclient.PostLogSet{}, err
	}

	p := insight_goclient.PostLogSet{
		Name:        data.Get("name").(string),
		Description: data.Get("description").(string),
		UserData:    decodedUserData,
		LogsInfo:    logsInfo,
	}
	return p, nil
}

func makePutLogSet(data *schema.ResourceData, client *insight_goclient.LogEntriesClient) (insight_goclient.PutLogSet, error) {
	var decodedLogsInfo []insight_goclient.LogInfo
	var decodedUserData map[string]string
	var err error

	if _, decodedLogsInfo, err = decodeLogsInfo(data, true, client); err != nil {
		return insight_goclient.PutLogSet{}, err
	}

	if err := mapstructure.Decode(data.Get("user_data").(map[string]interface{}), &decodedUserData); err != nil {
		return insight_goclient.PutLogSet{}, err
	}

	p := insight_goclient.PutLogSet{
		Name:        data.Get("name").(string),
		Description: data.Get("description").(string),
		UserData:    decodedUserData,
		LogsInfo:    decodedLogsInfo,
	}
	return p, nil
}
